// src/hooks/useAutoSessions.ts

import { useState, useEffect, useCallback, useRef } from 'react';
import type { AutoSession, SessionStats } from '@/types/session';

interface UseAutoSessionsReturn {
  availableSessions: AutoSession[];
  currentSession: AutoSession | null;
  sessionStats: SessionStats | null;
  isLoading: boolean;
  error: string | null;
  joinSession: (sessionId: string) => void;
  refreshSessions: () => Promise<void>;
}

export const useAutoSessions = (): UseAutoSessionsReturn => {
  // State
  const [availableSessions, setAvailableSessions] = useState<AutoSession[]>([]);
  const [currentSession, setCurrentSession] = useState<AutoSession | null>(null);
  const [sessionStats, setSessionStats] = useState<SessionStats | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // Refs
  const syncIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const isInitializedRef = useRef(false);

  // API Base URL
  const API_BASE = import.meta.env.VITE_BACKEND_API || 'http://localhost:3002';

  // Fetch active sessions from backend
  const fetchActiveSessions = useCallback(async (): Promise<AutoSession[]> => {
    try {
      const response = await fetch(`${API_BASE}/api/sessions/active`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      console.log('Fetched active sessions:', data);
      
      // Transform backend data to frontend format
      return data.sessions?.map((session: any) => ({
        ...session,
        createdAt: new Date(session.createdAt),
        isAutoGenerated: true,
      })) || [];

    } catch (err) {
      console.error('Failed to fetch sessions:', err);
      throw err;
    }
  }, [API_BASE]);

  // Fetch session statistics
  const fetchSessionStats = useCallback(async (): Promise<SessionStats> => {
    try {
      const response = await fetch(`${API_BASE}/api/sessions/stats`);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const stats = await response.json();
      console.log('Fetched session stats:', stats);
      return stats;

    } catch (err) {
      console.error('Failed to fetch session stats:', err);
      // Return default stats on error
      return {
        totalSessions: 0,
        activeSessions: 0,
        totalViewers: 0,
        averageSessionDuration: 0
      };
    }
  }, [API_BASE]);

  // Refresh all session data
  const refreshSessions = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      console.log('Refreshing sessions...');
      
      // Fetch both sessions and stats in parallel
      const [sessions, stats] = await Promise.all([
        fetchActiveSessions(),
        fetchSessionStats()
      ]);

      setAvailableSessions(sessions);
      setSessionStats(stats);

      // Auto-join first live session if none selected
      if (!currentSession && sessions.length > 0) {
        const liveSession = sessions.find(s => s.isLive) || sessions[0];
        if (liveSession) {
          console.log('Auto-joining session:', liveSession.id);
          setCurrentSession(liveSession);
        }
      }

      console.log('Sessions refreshed successfully');
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      console.error('Refresh failed:', errorMessage);
      setError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [fetchActiveSessions, fetchSessionStats, currentSession]);

  // Join specific session
  const joinSession = useCallback((sessionId: string) => {
    const session = availableSessions.find(s => s.id === sessionId);
    
    if (session) {
      console.log('Joining session:', sessionId);
      setCurrentSession(session);
      setError(null);
    } else {
      console.warn('Session not found:', sessionId);
      setError(`Session ${sessionId} not found`);
    }
  }, [availableSessions]);

  // Setup automatic background sync
  useEffect(() => {
    if (!isInitializedRef.current) {
      console.log('Initializing auto-sessions...');
      
      // Initial load
      refreshSessions();
      isInitializedRef.current = true;

      // Setup continuous sync every 15 seconds
      syncIntervalRef.current = setInterval(() => {
        console.log('⏰ Background session sync...');
        refreshSessions();
      }, 15000);
    }

    // Cleanup interval on unmount
    return () => {
      if (syncIntervalRef.current) {
        clearInterval(syncIntervalRef.current);
        syncIntervalRef.current = null;
      }
    };
  }, [refreshSessions]);

  // Update current session when available sessions change
  useEffect(() => {
    if (currentSession && availableSessions.length > 0) {
      // Update current session with latest data
      const updatedSession = availableSessions.find(s => s.id === currentSession.id);
      
      if (updatedSession) {
        setCurrentSession(updatedSession);
      } else {
        // Current session ended, switch to another live session
        console.log('Current session ended, finding new session...');
        const liveSession = availableSessions.find(s => s.isLive);
        setCurrentSession(liveSession || null);
      }
    }
  }, [availableSessions, currentSession]);

  return {
    availableSessions,
    currentSession,
    sessionStats,
    isLoading,
    error,
    joinSession,
    refreshSessions
  };
};